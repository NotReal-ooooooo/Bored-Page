<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2D SHENANIGAN | Bored Page</tittle>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; }
    canvas { background-color: #87CEEB; display: block; cursor: crosshair; }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const tileSize = 15;
  const speed = 4;
  const gravity = 0.5;
  const jumpPower = -8;
  const breakTime = 20;
  const shootDelay = 0.00000000000000000000000000000000000000000000000001;
  const playerImg = new Image();
  
  let velocityY = 0;
  let isOnGround = false;
  let keysPressed = { left: false, right: false };
  let mouseX = 0, mouseY = 0;
  let isBreaking = false;
  let breakTimer = 0;
  let isMouseDown = false;
  let isShooting = false;
  let shootCooldown = 0;

    
  playerImg.src = 'pish.png';
  let playerDirection = 'right';

  const player = {
    x: 100,
    y: 100,
    width: tileSize,
    height: tileSize,
    health: 100,
    invincible: false
  };

  const bullets = [];
  const explosions = [];

  const enemies = [
    {
      x: 500,
      y: 100,
      width: tileSize,
      height: tileSize,
      color: 'red',
      speed: 3,
      health: 100,
      alive: true,
      velocityY: 0,
      onGround: false
    }
  ];

  let respawnTimer = 0;
  let deathCount = 0;
  const placedBlocks = [];
  let platformBlock;

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    generateGround();
  }

  function generateGround() {
    const groundY = canvas.height - tileSize;
    platformBlock = { x: Math.floor(canvas.width / 2 / tileSize) * tileSize, y: groundY - tileSize, width: tileSize, height: tileSize, broken: false };
  }

  function drawHealthBar(entity) {
    const barWidth = entity.width;
    const barHeight = 5;
    const healthPercent = entity.health / 100;
    ctx.fillStyle = 'black';
    ctx.fillRect(entity.x, entity.y - 10, barWidth, barHeight);
    ctx.fillStyle = 'lime';
    ctx.fillRect(entity.x, entity.y - 10, barWidth * healthPercent, barHeight);
  }

  function drawPlayer() {
    if (playerDirection === 'left') {
      ctx.save();
      ctx.scale(-1, 1);
      ctx.drawImage(playerImg, -player.x - player.width, player.y, player.width, player.height);
      ctx.restore();
    } else {
      ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);
    }
    drawHealthBar(player);
  }

  function drawEnemies() {
    enemies.forEach(enemy => {
      if (enemy.alive) {
        ctx.fillStyle = enemy.color;
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        drawHealthBar(enemy);
      }
    });
  }

  function drawBullets() {
    ctx.fillStyle = 'black';
    bullets.forEach(bullet => {
      ctx.fillRect(bullet.x, bullet.y, 8, 8);
    });
  }

  function createExplosion(x, y) {
    explosions.push({ x, y, radius: 400, alpha: 1 });
  }

  function drawExplosions() {
    explosions.forEach(explosion => {
      ctx.beginPath();
      ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(235, 235, 0, ${explosion.alpha})`; // orange color
      ctx.fill();
    });
  }

  function drawEnemyCount() {
  const aliveEnemies = enemies.filter(e => e.alive).length;
  ctx.font = '16px Arial';
  ctx.fillStyle = 'red';
  ctx.textAlign = 'right';
  ctx.fillText(`Enemies: ${aliveEnemies}`, canvas.width - 10, 20);
}
    
  function updateExplosions() {
  for (let i = explosions.length - 1; i >= 0; i--) {
    const ex = explosions[i];
    ex.radius += 2;
    ex.alpha -= 0.05;

    enemies.forEach(enemy => {
      if (enemy.alive) {
        const dx = (enemy.x + enemy.width / 2) - ex.x;
        const dy = (enemy.y + enemy.height / 2) - ex.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < ex.radius) {
          enemy.health -= enemy.isSuper ? 1 : 10; // clearer logic
        }
      }
    });

    if (ex.alpha <= 0) {
      explosions.splice(i, 1);
    }
  }
}


  function drawGround() {
    ctx.fillStyle = 'green';
    ctx.fillRect(0, canvas.height - tileSize, canvas.width, tileSize);

    if (!platformBlock.broken) {
      ctx.fillStyle = '#a0a8ad';
      ctx.fillRect(platformBlock.x, platformBlock.y, platformBlock.width, platformBlock.height);
    }

    placedBlocks.forEach(block => {
      ctx.fillStyle = '#a0a8ad';
      ctx.fillRect(block.x, block.y, block.width, block.height);
    });
  }

  function updatePlayerMovement() {
    if (keysPressed.left && player.x > 0) {
      player.x -= speed;
      playerDirection = 'left';
    }
    if (keysPressed.right && player.x + player.width < canvas.width) {
      player.x += speed;
      playerDirection = 'right';
    }

    velocityY += gravity;
    player.y += velocityY;
    isOnGround = false;

    if (player.y + player.height > canvas.height - tileSize) {
      player.y = canvas.height - tileSize - player.height;
      velocityY = 0;
      isOnGround = true;
    }

    placedBlocks.forEach(block => {
      const hitX = player.x < block.x + block.width && player.x + player.width > block.x;
      const hitY = player.y + player.height >= block.y && player.y + player.height <= block.y + velocityY + 1;
      if (hitX && hitY && velocityY >= 0) {
        isOnGround = true;
        velocityY = 0;
        player.y = block.y - player.height;
      }
    });
  }

  function updateEnemy() {
    enemies.forEach(enemy => {
      if (!enemy.alive) {
        respawnTimer++;
        if (respawnTimer >= 600) {
          enemy.x = 500;
          enemy.y = 100;
          enemy.health = 100;
          enemy.alive = true;
          respawnTimer = 0;
        }
        return;
      }

      const direction = player.x > enemy.x ? 1 : -1;
      enemy.x += direction * enemy.speed;
      enemy.velocityY += gravity;
      enemy.y += enemy.velocityY;
      enemy.onGround = false;

      if (enemy.y + enemy.height > canvas.height - tileSize) {
        enemy.y = canvas.height - tileSize - enemy.height;
        enemy.velocityY = jumpPower;
        enemy.onGround = true;
      }

      if (enemy.health <= 0) {
        enemy.alive = false;
        deathCount++;

        // Duplicate enemy after 5 kills
        if (deathCount >= 5) {
          const newEnemy = { ...enemy, x: enemy.x + 50, y: 100, alive: true, health: 100 };
          enemies.push(newEnemy); // Add a duplicate enemy
          deathCount = 0; // Reset death count
       const aliveEnemies = enemies.filter(e => e.alive).length;

            if (aliveEnemies == 100 && !enemies.some(e => e.isSuper)) {
  forgeSuperEnemy();
}

        
        }
      }
    });
  }

let superEnemyCount = 0; // Place this near the top with your other global variables

function forgeSuperEnemy() {
  superEnemyCount++;

  enemies.length = 0;

  enemies.push({
    x: 400,
    y: 100,
    width: tileSize * 3,
    height: tileSize * 3,
    color: 'darkred',
    speed: 2,
    health: 50,
    alive: true,
    velocityY: 0,
    onGround: false,
    isSuper: true
  });

  console.log(`Super Enemy #${superEnemyCount} has been forged!`);
}


    
   
    
    function updateBullets() {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const bullet = bullets[i];
    bullet.x += bullet.vx;
    bullet.y += bullet.vy;

    let hit = false;

    // Check for enemy collision
    // inside updateBullets()
enemies.forEach(enemy => {
  if (
    enemy.alive &&
    bullet.x > enemy.x && bullet.x < enemy.x + enemy.width &&
    bullet.y > enemy.y && bullet.y < enemy.y + enemy.height
  ) {
    hit = true; // Don't apply damage here
  }
});


    // Check for canvas boundaries (left, right, top, bottom)
    if (
      bullet.x < 0 || bullet.x > canvas.width ||
      bullet.y < 0 || bullet.y > canvas.height - tileSize
    ) {
      hit = true;
    }

    if (hit) {
      createExplosion(bullet.x, bullet.y);
      bullets.splice(i, 1);
    }
  }
}


  function checkCollisions() {
    enemies.forEach(enemy => {
      if (enemy.alive && !player.invincible &&
          player.x < enemy.x + enemy.width && player.x + player.width > enemy.x &&
          player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
        player.health -= 10;
        player.invincible = true;
        setTimeout(() => player.invincible = false, 1000);
      }
    });
  }

  function updateBreaking() {
    if (isMouseDown) {
      if (isCursorOver(platformBlock) && !platformBlock.broken) {
        breakTimer++;
        if (breakTimer >= breakTime) {
          platformBlock.broken = true;
          breakTimer = 0;
        }
      }
      placedBlocks.forEach((block, index) => {
        if (isCursorOver(block)) {
          breakTimer++;
          if (breakTimer >= breakTime) {
            placedBlocks.splice(index, 1);
            breakTimer = 0;
          }
        }
      });
    }
  }

  function shootBullet() {
    const angle = Math.atan2(mouseY - (player.y + player.height / 2), mouseX - (player.x + player.width / 2));
    bullets.push({
      x: player.x + player.width / 2,
      y: player.y + player.height / 2,
      vx: Math.cos(angle) * 10,
      vy: Math.sin(angle) * 10
    });
  }

  function isCursorOver(block) {
    return mouseX > block.x && mouseX < block.x + block.width &&
           mouseY > block.y && mouseY < block.y + block.height;
  }

  function keyDown(event) {
    if ((event.key === 'ArrowUp' || event.key === ' ') && isOnGround) {
      velocityY = jumpPower;
    }
    if (event.key === 'ArrowLeft') keysPressed.left = true;
    if (event.key === 'ArrowRight') keysPressed.right = true;

    if (event.key === 'p' || event.key === 'P') {
      isShooting = true;
    }

    if ((event.key === 'e' || event.key === 'E') && platformBlock.broken) {
      placedBlocks.push({
        x: Math.floor(mouseX / tileSize) * tileSize,
        y: Math.floor(mouseY / tileSize) * tileSize,
        width: tileSize,
        height: tileSize
      });
    }
  }

  function keyUp(event) {
    if (event.key === 'ArrowLeft') keysPressed.left = false;
    if (event.key === 'ArrowRight') keysPressed.right = false;

    if (event.key === 'p' || event.key === 'P') {
      isShooting = false;
    }
  }

  function mouseMove(event) {
    const rect = canvas.getBoundingClientRect();
    mouseX = event.clientX - rect.left;
    mouseY = event.clientY - rect.top;
  }

  function mouseDown(event) {
    if (event.button === 0) {
      isMouseDown = true;
      breakTimer = 0;
      shootBullet();
    }
  }

  function mouseUp(event) {
    if (event.button === 0) {
      isMouseDown = false;
      breakTimer = 0;
    }
  }

  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (isShooting) {
      shootCooldown--;
      if (shootCooldown <= 0) {
        shootBullet();
        shootCooldown = shootDelay;
      }
    }
    drawGround();
    updatePlayerMovement();
    updateEnemy();
    updateBullets();
    updateBreaking();
    updateExplosions();
    checkCollisions();
    drawPlayer();
    drawEnemies();
    drawBullets();
    drawExplosions();
    drawEnemyCount();
    requestAnimationFrame(gameLoop);
  }

  window.addEventListener('keydown', keyDown);
  window.addEventListener('keyup', keyUp);
  canvas.addEventListener('mousemove', mouseMove);
  canvas.addEventListener('mousedown', mouseDown);
  canvas.addEventListener('mouseup', mouseUp);
  window.addEventListener('resize', resizeCanvas);

  resizeCanvas();
  gameLoop();
</script>
</body>
</html>
