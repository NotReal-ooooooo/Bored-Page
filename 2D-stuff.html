<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2D SHENANIGAN | Bored Page</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; }
    canvas { background-color: #87CEEB; display: block; cursor: crosshair; }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const tileSize = 15;
  const speed = 4;
  const gravity = 0.5;
  const jumpPower = -8;
  const breakTime = 20;
  const shootDelay = 0.1; // fixed
  const playerImg = new Image();
  playerImg.src = "pish.png";

  let velocityY = 0;
  let isOnGround = false;
  let keysPressed = { left: false, right: false };
  let mouseX = 0, mouseY = 0;
  let breakTimer = 0;
  let isMouseDown = false;
  let isShooting = false;
  let shootCooldown = 0;
  let deathCount = 0;
  let respawnTimer = 0;
  let superEnemyCount = 0;

  const player = {
    x: 100,
    y: 100,
    width: tileSize,
    height: tileSize,
    health: 100,
    invincible: false
  };

  const bullets = [];
  const explosions = [];
  const placedBlocks = [];
  
  let platformBlock = { x:0, y:0, width:tileSize, height:tileSize, broken:false };

  const enemies = [
    {
      x: 500,
      y: 100,
      width: tileSize,
      height: tileSize,
      color: 'red',
      speed: 3,
      health: 100,
      alive: true,
      velocityY: 0,
      onGround: false
    }
  ];

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    generateGround();
  }

  function generateGround() {
    const groundY = canvas.height - tileSize;
    platformBlock = { 
      x: Math.floor(canvas.width / 2 / tileSize) * tileSize, 
      y: groundY - tileSize, 
      width: tileSize, 
      height: tileSize, 
      broken: false 
    };
  }

  function drawHealthBar(entity) {
    const barWidth = entity.width;
    const barHeight = 5;
    const hp = entity.health / 100;

    ctx.fillStyle = "black";
    ctx.fillRect(entity.x, entity.y - 10, barWidth, barHeight);

    ctx.fillStyle = "lime";
    ctx.fillRect(entity.x, entity.y - 10, barWidth * hp, barHeight);
  }

  function drawPlayer() {
    if (playerImg.complete) {
      if (playerDirection === 'left') {
        ctx.save();
        ctx.scale(-1, 1);
        ctx.drawImage(playerImg, -player.x - player.width, player.y, player.width, player.height);
        ctx.restore();
      } else {
        ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);
      }
    } else {
      ctx.fillStyle = "blue";
      ctx.fillRect(player.x, player.y, player.width, player.height);
    }
    drawHealthBar(player);
  }

  function drawEnemies() {
    enemies.forEach(enemy => {
      if (enemy.alive) {
        ctx.fillStyle = enemy.color;
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        drawHealthBar(enemy);
      }
    });
  }

  function drawBullets() {
    ctx.fillStyle = "black";
    bullets.forEach(b => {
      ctx.fillRect(b.x, b.y, 8, 8);
    });
  }

  function createExplosion(x, y) {
    explosions.push({ x, y, radius: 10, alpha: 1 });
  }

  function drawExplosions() {
    explosions.forEach(ex => {
      ctx.beginPath();
      ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(235,235,0,${ex.alpha})`;
      ctx.fill();
    });
  }

  function updateExplosions() {
    for (let i = explosions.length - 1; i >= 0; i--) {
      const ex = explosions[i];
      ex.radius += 2;
      ex.alpha -= 0.05;

      enemies.forEach(enemy => {
        if (enemy.alive) {
          const dx = enemy.x + enemy.width/2 - ex.x;
          const dy = enemy.y + enemy.height/2 - ex.y;
          const dist = Math.sqrt(dx*dx + dy*dy);

          if (dist < ex.radius) {
            enemy.health -= enemy.isSuper ? 1 : 10;
          }
        }
      });

      if (ex.alpha <= 0) explosions.splice(i, 1);
    }
  }

  function drawEnemyCount() {
    const alive = enemies.filter(e => e.alive).length;
    ctx.font = "16px Arial";
    ctx.fillStyle = "red";
    ctx.textAlign = "right";
    ctx.fillText(`Enemies: ${alive}`, canvas.width - 10, 20);
  }

  function drawGround() {
    ctx.fillStyle = "green";
    ctx.fillRect(0, canvas.height - tileSize, canvas.width, tileSize);

    if (!platformBlock.broken) {
      ctx.fillStyle = "#a0a8ad";
      ctx.fillRect(platformBlock.x, platformBlock.y, platformBlock.width, platformBlock.height);
    }

    placedBlocks.forEach(block => {
      ctx.fillStyle = "#a0a8ad";
      ctx.fillRect(block.x, block.y, block.width, block.height);
    });
  }

  function updatePlayerMovement() {
    if (keysPressed.left && player.x > 0) {
      player.x -= speed;
      playerDirection = 'left';
    }
    if (keysPressed.right && player.x + player.width < canvas.width) {
      player.x += speed;
      playerDirection = 'right';
    }

    velocityY += gravity;
    player.y += velocityY;
    isOnGround = false;

    if (player.y + player.height > canvas.height - tileSize) {
      player.y = canvas.height - tileSize - player.height;
      velocityY = 0;
      isOnGround = true;
    }

    placedBlocks.forEach(block => {
      const hitX = player.x < block.x + block.width && player.x + player.width > block.x;
      const hitY = player.y + player.height >= block.y && player.y + player.height <= block.y + velocityY + 1;
      if (hitX && hitY) {
        player.y = block.y - player.height;
        velocityY = 0;
        isOnGround = true;
      }
    });
  }

  function forgeSuperEnemy() {
    superEnemyCount++;
    enemies.length = 0;
    enemies.push({
      x: 400,
      y: 100,
      width: tileSize * 3,
      height: tileSize * 3,
      color: 'darkred',
      speed: 2,
      health: 50,
      alive: true,
      velocityY: 0,
      onGround: false,
      isSuper: true
    });
  }

  function updateEnemy() {
    enemies.forEach(enemy => {
      if (!enemy.alive) {
        respawnTimer++;
        if (respawnTimer >= 600) {
          enemy.x = 500;
          enemy.y = 100;
          enemy.health = 100;
          enemy.alive = true;
          respawnTimer = 0;
        }
        return;
      }

      const direction = player.x > enemy.x ? 1 : -1;
      enemy.x += direction * enemy.speed;
      enemy.velocityY += gravity;
      enemy.y += enemy.velocityY;

      if (enemy.y + enemy.height > canvas.height - tileSize) {
        enemy.y = canvas.height - tileSize - enemy.height;
        enemy.velocityY = jumpPower;
      }

      if (enemy.health <= 0) {
        enemy.alive = false;
        deathCount++;

        if (deathCount >= 5) {
          enemies.push({ ...enemy, x: enemy.x + 50, y: 100, alive: true, health: 100 });
          deathCount = 0;

          const alive = enemies.filter(e => e.alive).length;
          if (alive >= 100 && !enemies.some(e => e.isSuper)) {
            forgeSuperEnemy();
          }
        }
      }
    });
  }

  function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.vx;
      b.y += b.vy;
      let hit = false;

      enemies.forEach(enemy => {
        if (
          enemy.alive &&
          b.x > enemy.x && b.x < enemy.x + enemy.width &&
          b.y > enemy.y && b.y < enemy.y + enemy.height
        ) {
          enemy.health -= enemy.isSuper ? 1 : 10;
          hit = true;
        }
      });

      if (
        b.x < 0 || b.x > canvas.width ||
        b.y < 0 || b.y > canvas.height - tileSize
      ) hit = true;

      if (hit) {
        createExplosion(b.x, b.y);
        bullets.splice(i, 1);
      }
    }
  }

  function checkCollisions() {
    enemies.forEach(enemy => {
      if (enemy.alive && !player.invincible &&
          player.x < enemy.x + enemy.width && player.x + player.width > enemy.x &&
          player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
        player.health -= 10;
        player.invincible = true;
        setTimeout(() => player.invincible = false, 1000);
      }
    });
  }

  function updateBreaking() {
    if (isMouseDown) {
      if (isCursorOver(platformBlock) && !platformBlock.broken) {
        breakTimer++;
        if (breakTimer >= breakTime) {
          platformBlock.broken = true;
          breakTimer = 0;
        }
      }
      placedBlocks.forEach((block, i) => {
        if (isCursorOver(block)) {
          breakTimer++;
          if (breakTimer >= breakTime) {
            placedBlocks.splice(i, 1);
            breakTimer = 0;
          }
        }
      });
    }
  }

  function shootBullet() {
    const angle = Math.atan2(mouseY - (player.y + player.height / 2), mouseX - (player.x + player.width / 2));
    bullets.push({
      x: player.x + player.width / 2,
      y: player.y + player.height / 2,
      vx: Math.cos(angle) * 10,
      vy: Math.sin(angle) * 10
    });
  }

  function isCursorOver(block) {
    return (
      mouseX > block.x &&
      mouseX < block.x + block.width &&
      mouseY > block.y &&
      mouseY < block.y + block.height
    );
  }

  function keyDown(e) {
    if ((e.key === 'ArrowUp' || e.key === ' ') && isOnGround) velocityY = jumpPower;
    if (e.key === 'ArrowLeft') keysPressed.left = true;
    if (e.key === 'ArrowRight') keysPressed.right = true;
    if (e.key === 'p' || e.key === 'P') isShooting = true;

    if ((e.key === 'e' || e.key === 'E') && platformBlock.broken) {
      placedBlocks.push({
        x: Math.floor(mouseX / tileSize) * tileSize,
        y: Math.floor(mouseY / tileSize) * tileSize,
        width: tileSize,
        height: tileSize
      });
    }
  }

  function keyUp(e) {
    if (e.key === 'ArrowLeft') keysPressed.left = false;
    if (e.key === 'ArrowRight') keysPressed.right = false;
    if (e.key === 'p' || e.key === 'P') isShooting = false;
  }

  function mouseMove(e) {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
  }

  function mouseDown(e) {
    if (e.button === 0) {
      isMouseDown = true;
      breakTimer = 0;
      shootBullet();
    }
  }

  function mouseUp(e) {
    if (e.button === 0) {
      isMouseDown = false;
      breakTimer = 0;
    }
  }

  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (isShooting) {
      shootCooldown--;
      if (shootCooldown <= 0) {
        shootBullet();
        shootCooldown = shootDelay;
      }
    }

    drawGround();
    updatePlayerMovement();
    updateEnemy();
    updateBullets();
    updateBreaking();
    updateExplosions();
    checkCollisions();

    drawPlayer();
    drawEnemies();
    drawBullets();
    drawExplosions();
    drawEnemyCount();

    requestAnimationFrame(gameLoop);
  }

  window.addEventListener("keydown", keyDown);
  window.addEventListener("keyup", keyUp);
  canvas.addEventListener("mousemove", mouseMove);
  canvas.addEventListener("mousedown", mouseDown);
  canvas.addEventListener("mouseup", mouseUp);
  window.addEventListener("resize", resizeCanvas);

  let playerDirection = 'right';
  resizeCanvas();
  gameLoop();
</script>
</body>
</html>
