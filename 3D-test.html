<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bored Page | 3D stuff</title>
    <link rel="icon" type="image/png" href="canvas.png">
    <style>
        /* General Body and Canvas Styles */
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: sans-serif; 
        }
        canvas { 
            display: block; 
        }

        /* UI Overlay Elements */
        #info, #instructions {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            z-index: 100;
            text-shadow: 2px 2px 4px #000000;
        }

        #info {
            top: 10px;
        }

        #instructions {
            bottom: 10px;
            font-size: 1.2em;
        }

        #game-message, #wave-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-shadow: 4px 4px 6px #000000;
            z-index: 200;
            display: none;
            text-align: center;
        }

        #game-message {
            font-size: 3em;
        }

        #wave-message {
            top: 40%;
            font-size: 2em;
        }

        /* Gear Icon Styles */
        #gear-icon-container {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            padding: 5px;
        }
        
        .gear {
            fill: #ecf0f1;
            transform-origin: 50% 50%;
            animation: rotate 8s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Menu Styles */
        #settings-menu, #buff-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            color: white;
            text-align: center;
            display: none;
            z-index: 300;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        #settings-menu h2, #buff-menu h2 {
            margin-top: 0;
            font-size: 1.5em;
        }

        .setting-item {
            margin-bottom: 20px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
        }

        .setting-item input[type="range"] {
            width: 100%;
        }

        .button {
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }

        .button:hover {
            background-color: #2980b9;
        }

        /* Buff Menu Specific Styles */
        #buff-menu {
            width: 500px;
        }

        #buff-menu h2 {
            font-size: 1.8em;
            margin-bottom: 20px;
        }
        
        #buff-choices {
            display: flex;
            justify-content: space-around;
            gap: 20px;
        }

        .buff-button {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background-color: #34495e;
            border: 2px solid #2c3e50;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        .buff-button:hover {
            background-color: #496277;
            transform: translateY(-5px);
        }

        .buff-title {
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .buff-description {
            font-size: 0.9em;
            opacity: 0.8;
        }

        /* Crosshair Styles */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background-color: white;
            border-radius: 50%;
            z-index: 99;
            pointer-events: none;
            display: none;
        }

        #rank-button {
    position: fixed;
    top: 20px;
    left: 20px;
    background: rgba(0,0,0,0.6);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    z-index: 150;
    font-size: 14px;
    user-select: none;
}
#rank-panel {
    position: fixed;
    top: 60px;
    left: 20px;
    background: rgba(0,0,0,0.85);
    color: white;
    padding: 10px;
    border-radius: 8px;
    display: none; /* hidden by default */
    z-index: 150;
    max-height: 300px;
    overflow-y: auto;
    font-size: 14px;
    min-width: 120px;
}
#rank-panel h3 { margin: 0 0 6px 0; font-size: 16px; text-align: center; }

        
    </style>
</head>
<body>
<div id="rank-button">Ranks</div>
<div id="rank-panel"></div>
    
     <audio id="shoot-sound" src="shooting-n-reload.mp3" preload="auto"></audio>
    
    <div id="info">Use WASD or Arrow Keys to Move and Turn the Player</div>

    <div id="crosshair"></div>

    <div id="gear-icon-container">
        <svg class="gear" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
            <circle cx="50" cy="50" r="40" />
            <circle cx="50" cy="50" r="15" fill="#2c3e50" />
            <path d="M 50,10 L 58,22 L 42,22 z" />
            <path d="M 88,42 L 88,58 L 78,50 z" transform="rotate(36 50 50)" />
            <path d="M 88,42 L 88,58 L 78,50 z" transform="rotate(72 50 50)" />
            <path d="M 88,42 L 88,58 L 78,50 z" transform="rotate(108 50 50)" />
            <path d="M 88,42 L 88,58 L 78,50 z" transform="rotate(144 50 50)" />
            <path d="M 88,42 L 88,58 L 78,50 z" transform="rotate(180 50 50)" />
            <path d="M 88,42 L 88,58 L 78,50 z" transform="rotate(216 50 50)" />
            <path d="M 88,42 L 88,58 L 78,50 z" transform="rotate(252 50 50)" />
            <path d="M 88,42 L 88,58 L 78,50 z" transform="rotate(288 50 50)" />
            <path d="M 88,42 L 88,58 L 78,50 z" transform="rotate(324 50 50)" />
        </svg>
    </div>

    <div id="settings-menu">
        <h2>Settings</h2>
        <div class="setting-item">
            <label for="sensitivity-slider">Mouse Sensitivity</label>
            <input type="range" id="sensitivity-slider" min="0.0005" max="0.005" step="0.0001" value="0.002">
        </div>
        <button class="button" id="resume-button">Resume</button>
    </div>
    
    <div id="buff-menu">
        <h2>Choose Your Buff</h2>
        <div id="buff-choices">
            <div id="buff-choice-1" class="buff-button">
                <span class="buff-title"></span>
                <span class="buff-description"></span>
            </div>
            <div id="buff-choice-2" class="buff-button">
                <span class="buff-title"></span>
                <span class="buff-description"></span>
            </div>
        </div>
    </div>

    <div id="game-message"></div>
    <div id="wave-message"></div>

    <!-- Three.js library is loaded from a CDN -->
  <script type="module">
import * as THREE from "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js";

  const rankButton = document.getElementById("rank-button");
const rankPanel = document.getElementById("rank-panel");

async function fetchLeaderboard() {
  const q = query(collection(db, "scores"), orderBy("kills", "desc"), limit(30));
  const snap = await getDocs(q);
  return snap.docs.map((doc, i) => `${i + 1}. ${doc.data().kills} kills`);
}

rankButton.addEventListener("click", async () => {
  if (rankPanel.style.display === "block") {
    rankPanel.style.display = "none";
    return;
  }
  rankPanel.style.display = "block";
  rankPanel.innerHTML = "<h3>Ranks</h3><div>Loadingâ€¦</div>";

  const list = await fetchLeaderboard();
  rankPanel.innerHTML = "<h3>Ranks</h3>" + list.join("<br>");
});

      
  // Import Firebase SDK
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getFirestore, doc, setDoc, getDoc, collection, query, orderBy, limit, getDocs, increment, updateDoc } 
    from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } 
    from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";

  // ðŸ”¹ Paste your Firebase config from console here
const firebaseConfig = {

  apiKey: "AIzaSyDHwRWR9aP00Kj4uKQUD2aXymca0SuoDfc",
  authDomain: "server-50ccc.firebaseapp.com",
  projectId: "server-50ccc",
  storageBucket: "server-50ccc.firebasestorage.app",
  messagingSenderId: "210801120477",
  appId: "1:210801120477:web:ce071117ecd2ba3704f734",
  measurementId: "G-9ZN3S2VCKE"

};


  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  // Sign in anonymously
  let currentUser = null;
  signInAnonymously(auth);
  onAuthStateChanged(auth, user => {
    currentUser = user;
    console.log("Signed in as", user.uid);
  });

let localKills = 0; // track kills this run

function addKill() {
  localKills++;
}

// Call this when game ends
async function saveHighScore() {
  if (!currentUser) return;

  const ref = doc(db, "scores", currentUser.uid);
  const snap = await getDoc(ref);

  if (!snap.exists()) {
    // first time playing
    await setDoc(ref, { kills: localKills });
  } else {
    const oldScore = snap.data().kills || 0;
    if (localKills > oldScore) {
      await updateDoc(ref, { kills: localKills });
    }
  }
}

        
        window.onload = function() {
            // --- Global Variables ---
            let scene, camera, renderer;
            let player;
            let followers = [];
            let superFollowers = [];
            let omegaFollowers = []; // NEW: Array for the new enemy type
            let healthOrbs = [];
            let playerHealth = 100;
            let playerMaxHealth = 100;
            let gameIsOver = false;
            let isPaused = false;
            let isFirstPersonView = false;
            let onGround = false;
            let playerVelocity = new THREE.Vector3();
            let keys = {};
            let blocks = [];
            const playerProjectiles = [];
            const followerProjectiles = [];
            let playerLastShotTime = 0;
            let waveCount = 0;
            let isWaveTransitioning = false;
            
            // Mouse movement variables for first-person view
            let isMouseLocked = false;
            let cameraRotation = new THREE.Vector2();
            
            // --- Game Constants (These will be modified by buffs) ---
            let playerSpeed = 0.2;
            const rotationSpeed = 0.05;
            const followerSpeed = 0.05;
            const superFollowerSpeed = 0.07;
            const omegaFollowerSpeed = 0.09; // NEW: Speed for the new enemy
            const gravity = 0.05;
            const jumpForce = 1.0;
            const followerProjectileDamage = 15;
            const followerExplosionDamage = 20;
            const superFollowerProjectileDamage = 35;
            const superFollowerExplosionDamage = 40;
            const omegaFollowerProjectileDamage = 60; // NEW: Damage for the new enemy's projectile
            const omegaFollowerExplosionDamage = 80; // NEW: Explosion damage for the new enemy's projectile
            const fireCooldown = 1500;
            const superFireCooldown = 1000;
            const omegaFireCooldown = 750; // NEW: Cooldown for the new enemy's fire
            let playerShotDamage = 20;
            let playerShotCooldown = 500;
            const playerProjectileSpeed = 1.0;
            const fireRadius = 7;
            const fireDuration = 500;
            const throwingRange = 20;
            const initialFollowerCount = 2;
            const worldRadius = 50;
            const voidYLevel = -10;
            const combinationThreshold = 5;
            const omegaFollowerThreshold = 5; // NEW: The number of super followers needed to combine
            const healthOrbHealAmount = 10;
            const followerMaxHealth = 100;
            const superFollowerMaxHealth = 500;
            const omegaFollowerMaxHealth = 2500; // NEW: Health for the new enemy
            
            // --- Buff Definitions ---
            const buffs = [
                {
                    name: "Player Damage Up",
                    description: "Your attacks deal more damage.",
                    apply: () => { playerShotDamage += 10; }
                },
                {
                    name: "Shooting Speed Up",
                    description: "Decreases the time between your shots.",
                    apply: () => { playerShotCooldown = Math.max(100, playerShotCooldown - 100); }
                },
                {
                    name: "Player Speed Up",
                    description: "Increases your movement speed.",
                    apply: () => { playerSpeed += 0.05; }
                },
                {
                    name: "Health Boost",
                    description: "Increases your max health and restores health.",
                    apply: () => {
                        playerMaxHealth += 25;
                        playerHealth = Math.min(playerMaxHealth, playerHealth + 25);
                    }
                }
            ];
            
            // --- HTML Elements ---
            const gameMessage = document.getElementById('game-message');
            const waveMessage = document.getElementById('wave-message');
            const crosshair = document.getElementById('crosshair');
            const gearIcon = document.getElementById('gear-icon-container');
            const settingsMenu = document.getElementById('settings-menu');
            const resumeButton = document.getElementById('resume-button');
            const sensitivitySlider = document.getElementById('sensitivity-slider');
            const buffMenu = document.getElementById('buff-menu');
            const buffChoice1Button = document.getElementById('buff-choice-1');
            const buffChoice2Button = document.getElementById('buff-choice-2');
            
            let mouseSensitivity = parseFloat(sensitivitySlider.value);
            
            // --- Setup Functions ---
            function init() {
                localKills = 0;
                // Scene setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87ceeb);
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 10, 20);
                camera.lookAt(0, 0, 0);
                
                // Set camera rotation order to avoid gimbal lock
                camera.rotation.order = 'YXZ';
                
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 10, 7.5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -30;
                directionalLight.shadow.camera.right = 30;
                directionalLight.shadow.camera.top = 30;
                directionalLight.shadow.camera.bottom = -30;
                scene.add(directionalLight);
                
                // Ground Plane
                const groundGeometry = new THREE.PlaneGeometry(100, 100);
                const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                scene.add(ground);
                
                // Player
                const playerGeometry = new THREE.BoxGeometry(2, 2, 2);
                const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
                player = new THREE.Mesh(playerGeometry, playerMaterial);
                player.position.y = 1;
                player.castShadow = true;
                scene.add(player);
                
                // Player Health Bar
                const playerHealthBar = createHealthBar(2, 0.2);
                playerHealthBar.position.y = 2; // Position above the player's head
                player.add(playerHealthBar);
                player.healthBar = playerHealthBar;
                
                // Bushes
                blocks = [];
                const spawnedPositions = [];
                const minDistance = 10;
                const numBushes = Math.floor(Math.random() * 21) + 20;
                for (let i = 0; i < numBushes; i++) {
                    let positionFound = false;
                    let newBushPosition;
                    let attempts = 0;
                    while (!positionFound && attempts < 50) {
                        newBushPosition = new THREE.Vector3(
                            (Math.random() * 80) - 40,
                            0,
                            (Math.random() * 80) - 40
                        );
                        let tooClose = false;
                        for (const pos of spawnedPositions) {
                            if (newBushPosition.distanceTo(pos) < minDistance) {
                                tooClose = true;
                                break;
                            }
                        }
                        if (!tooClose) {
                            positionFound = true;
                        }
                        attempts++;
                    }
                    if (positionFound) {
                        const bushRadius = Math.random() * 2 + 1.5;
                        const newBush = createBush(bushRadius);
                        newBush.mesh.position.copy(newBushPosition);
                        newBush.mesh.position.y = -bushRadius/2;
                        scene.add(newBush.mesh);
                        blocks.push(newBush);
                        spawnedPositions.push(newBushPosition);
                    }
                }
                
                // Initial state
                gameIsOver = false;
                isPaused = false;
                playerHealth = 100;
                playerMaxHealth = 100;
                gameMessage.style.display = 'none';
                settingsMenu.style.display = 'none';
                buffMenu.style.display = 'none';
                crosshair.style.display = 'none';
                isFirstPersonView = false;
                camera.position.set(0, 10, 20);
                camera.lookAt(0, 0, 0);

                spawnNewWave(initialFollowerCount);
            }
            
            function createHealthBar(width, height) {
                const healthBarContainer = new THREE.Group();
                const containerGeometry = new THREE.PlaneGeometry(width, height);
                const containerMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const containerMesh = new THREE.Mesh(containerGeometry, containerMaterial);
                
                const fillGeometry = new THREE.PlaneGeometry(width * 0.9, height * 0.7);
                const fillMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const fillMesh = new THREE.Mesh(fillGeometry, fillMaterial);
                fillMesh.position.x = -width * 0.05;
                
                healthBarContainer.add(containerMesh);
                healthBarContainer.add(fillMesh);
                healthBarContainer.fillMesh = fillMesh;
                
                // Store the original width for scaling calculations
                healthBarContainer.userData.width = width; 
                
                return healthBarContainer;
            }
            
            function updateHealthBar(healthBar, currentHealth, maxHealth) {
                const newScale = currentHealth / maxHealth;
                const barWidth = healthBar.userData.width;
                healthBar.fillMesh.scale.x = newScale;
                healthBar.fillMesh.position.x = -(barWidth / 2) * (1 - newScale);
                
                if (currentHealth / maxHealth > 0.5) {
                    healthBar.fillMesh.material.color.setHex(0x00ff00);
                } else if (currentHealth / maxHealth > 0.25) {
                    healthBar.fillMesh.material.color.setHex(0xffff00);
                } else {
                    healthBar.fillMesh.material.color.setHex(0xff0000);
                }
            }
            
            function createBush(radius) {
                const bushGroup = new THREE.Group();
                const bushMaterial = new THREE.MeshStandardMaterial({ color: 0x006400 });
                const numSpheres = 10;
                let maxSphereRadius = 0;
                for (let i = 0; i < numSpheres; i++) {
                    const sphereRadius = radius * (0.5 + Math.random() * 0.5);
                    const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
                    const sphereMesh = new THREE.Mesh(sphereGeometry, bushMaterial);
                    const x = (Math.random() - 0.5) * radius * 2;
                    const z = (Math.random() - 0.5) * radius * 2;
                    const y = sphereRadius;
                    sphereMesh.position.set(x, y, z);
                    sphereMesh.castShadow = true;
                    bushGroup.add(sphereMesh);
                    if (sphereRadius > maxSphereRadius) {
                        maxSphereRadius = sphereRadius;
                    }
                }
                bushGroup.position.y = -radius/2;
                return { mesh: bushGroup, radius: radius + maxSphereRadius };
            }
            
            function createHealthOrb(position) {
                const orbGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const orbMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                orb.position.copy(position);
                orb.position.y = 0.5;
                scene.add(orb);
                healthOrbs.push(orb);
            }
            
            // NEW: Combines 5 super followers into a single, stronger omega follower
            function combineSuperFollowers() {
                const superFollowersToCombine = superFollowers.slice(0, omegaFollowerThreshold);
                let totalPos = new THREE.Vector3();
                superFollowersToCombine.forEach(f => {
                    totalPos.add(f.mesh.position);
                    scene.remove(f.mesh);
                });
                
                const newPos = totalPos.divideScalar(superFollowersToCombine.length);
                
                const omegaFollowerGeometry = new THREE.BoxGeometry(6, 6, 6);
                const omegaFollowerMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                const newOmegaFollowerMesh = new THREE.Mesh(omegaFollowerGeometry, omegaFollowerMaterial);
                newOmegaFollowerMesh.position.copy(newPos);
                newOmegaFollowerMesh.castShadow = true;
                scene.add(newOmegaFollowerMesh);

                const omegaFollowerHealthBar = createHealthBar(6, 0.6);
                omegaFollowerHealthBar.position.y = 6;
                newOmegaFollowerMesh.add(omegaFollowerHealthBar);

                omegaFollowers.push({
                    mesh: newOmegaFollowerMesh,
                    health: omegaFollowerMaxHealth,
                    healthBar: omegaFollowerHealthBar,
                    lastFireTime: 0
                });

                superFollowers.splice(0, omegaFollowerThreshold);
            }

            // --- Event Listeners ---
            document.addEventListener('keydown', (event) => {
                keys[event.key.toLowerCase()] = true;
                if (event.key.toLowerCase() === 'v' && !gameIsOver && !isPaused) {
                    isFirstPersonView = !isFirstPersonView;
                    if (isFirstPersonView) {
                        renderer.domElement.requestPointerLock();
                        crosshair.style.display = 'block';
                    } else {
                        document.exitPointerLock();
                        crosshair.style.display = 'none';
                    }
                }
                if (event.key === ' ' && onGround && !gameIsOver && !isPaused) {
                    playerVelocity.y = jumpForce;
                }
                if ((event.key.toLowerCase() === 'x' || event.key.toLowerCase() === 'l') && !gameIsOver && !isPaused && (Date.now() - playerLastShotTime > playerShotCooldown)) {
                    firePlayerProjectile();
                    playerLastShotTime = Date.now();
                }
            });

            document.addEventListener('keyup', (event) => {
                keys[event.key.toLowerCase()] = false;
            });

            document.addEventListener('mousemove', (event) => {
                if (isMouseLocked) {
                    cameraRotation.y -= event.movementX * mouseSensitivity;
                    cameraRotation.x -= event.movementY * mouseSensitivity;
                    cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x));
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                isMouseLocked = document.pointerLockElement === renderer.domElement;
                if (!isMouseLocked && isFirstPersonView) {
                    isFirstPersonView = false;
                    crosshair.style.display = 'none';
                    camera.position.set(
                        player.position.x + Math.sin(player.rotation.y) * 20,
                        player.position.y + 10,
                        player.position.z + Math.cos(player.rotation.y) * 20
                    );
                    camera.lookAt(player.position);
                }
            });

            gearIcon.addEventListener('click', () => {
                isPaused = true;
                settingsMenu.style.display = 'block';
                document.exitPointerLock();
            });

            resumeButton.addEventListener('click', () => {
                isPaused = false;
                settingsMenu.style.display = 'none';
                if (isFirstPersonView) {
                    renderer.domElement.requestPointerLock();
                }
            });

            sensitivitySlider.addEventListener('input', (event) => {
                mouseSensitivity = parseFloat(event.target.value);
            });
            
            buffChoice1Button.addEventListener('click', () => {
                const chosenBuff = buffChoice1Button.buff;
                chosenBuff.apply();
                buffMenu.style.display = 'none';
                isPaused = false;
                isWaveTransitioning = false;
                updateHealthBar(player.healthBar, playerHealth, playerMaxHealth);
                spawnNewWave(initialFollowerCount * Math.pow(2, waveCount));
            });
            
            buffChoice2Button.addEventListener('click', () => {
                const chosenBuff = buffChoice2Button.buff;
                chosenBuff.apply();
                buffMenu.style.display = 'none';
                isPaused = false;
                isWaveTransitioning = false;
                updateHealthBar(player.healthBar, playerHealth, playerMaxHealth);
                spawnNewWave(initialFollowerCount * Math.pow(2, waveCount));
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // --- Game Logic Functions ---
            function combineFollowers() {
                if (followers.length < combinationThreshold) return;

                const followersToCombine = followers.slice(0, combinationThreshold);
                let totalPos = new THREE.Vector3();
                followersToCombine.forEach(f => {
                    totalPos.add(f.mesh.position);
                    scene.remove(f.mesh);
                });

                const newPos = totalPos.divideScalar(followersToCombine.length);
                const superFollowerGeometry = new THREE.BoxGeometry(4, 4, 4);
                const superFollowerMaterial = new THREE.MeshStandardMaterial({ color: 0x2c0000 });
                const newSuperFollowerMesh = new THREE.Mesh(superFollowerGeometry, superFollowerMaterial);
                newSuperFollowerMesh.position.copy(newPos);
                newSuperFollowerMesh.castShadow = true;
                scene.add(newSuperFollowerMesh);

                const superFollowerHealthBar = createHealthBar(4, 0.4);
                superFollowerHealthBar.position.y = 4;
                newSuperFollowerMesh.add(superFollowerHealthBar);

                superFollowers.push({
                    mesh: newSuperFollowerMesh,
                    health: superFollowerMaxHealth,
                    healthBar: superFollowerHealthBar,
                    lastFireTime: 0
                });

                followers.splice(0, combinationThreshold);
            }

            function fireBlob(follower) {
                if (Date.now() - follower.lastFireTime < fireCooldown) {
                    return;
                }
                
                const distance = follower.mesh.position.distanceTo(player.position);
                if (distance > throwingRange) {
                    return;
                }
                
                follower.lastFireTime = Date.now();
                
                const blobGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const blobMaterial = new THREE.MeshStandardMaterial({ color: 0x8b0000 });
                const projectile = new THREE.Mesh(blobGeometry, blobMaterial);
                projectile.position.copy(follower.mesh.position);
                projectile.castShadow = true;
                scene.add(projectile);
                
                const horizontalSpeed = 0.7;
                const horizontalDistance = new THREE.Vector2(player.position.x, player.position.z).distanceTo(new THREE.Vector2(follower.mesh.position.x, follower.mesh.position.z));
                const timeToHit = horizontalDistance / horizontalSpeed;
                
                const predictedPlayerPosition = new THREE.Vector3(
                    player.position.x,
                    player.position.y,
                    player.position.z
                );

                const initialYVelocity = (predictedPlayerPosition.y - follower.mesh.position.y + 0.5 * gravity * timeToHit * timeToHit) / timeToHit + 0.2;
                
                const direction = new THREE.Vector3();
                direction.subVectors(predictedPlayerPosition, follower.mesh.position).normalize();
                
                projectile.velocity = new THREE.Vector3(
                    direction.x * horizontalSpeed,
                    initialYVelocity,
                    direction.z * horizontalSpeed
                );

                followerProjectiles.push({ mesh: projectile, damage: followerProjectileDamage, explosionDamage: followerExplosionDamage });
            }

            function fireSuperBlob(superFollower) {
                if (Date.now() - superFollower.lastFireTime < superFireCooldown) {
                    return;
                }

                const distance = superFollower.mesh.position.distanceTo(player.position);
                if (distance > throwingRange * 1.5) {
                    return;
                }

                superFollower.lastFireTime = Date.now();

                const blobGeometry = new THREE.SphereGeometry(1, 16, 16);
                const blobMaterial = new THREE.MeshStandardMaterial({ color: 0x550000 });
                const projectile = new THREE.Mesh(blobGeometry, blobMaterial);
                projectile.position.copy(superFollower.mesh.position);
                projectile.castShadow = true;
                scene.add(projectile);

                const horizontalSpeed = 0.9;
                const horizontalDistance = new THREE.Vector2(player.position.x, player.position.z).distanceTo(new THREE.Vector2(superFollower.mesh.position.x, superFollower.mesh.position.z));
                const timeToHit = horizontalDistance / horizontalSpeed;

                const predictedPlayerPosition = new THREE.Vector3(
                    player.position.x,
                    player.position.y,
                    player.position.z
                );

                const initialYVelocity = (predictedPlayerPosition.y - superFollower.mesh.position.y + 0.5 * gravity * timeToHit * timeToHit) / timeToHit + 0.2;

                const direction = new THREE.Vector3();
                direction.subVectors(predictedPlayerPosition, superFollower.mesh.position).normalize();

                projectile.velocity = new THREE.Vector3(
                    direction.x * horizontalSpeed,
                    initialYVelocity,
                    direction.z * horizontalSpeed
                );

                followerProjectiles.push({ mesh: projectile, damage: superFollowerProjectileDamage, explosionDamage: superFollowerExplosionDamage });
            }
            
            // NEW: Firing function for the new omega follower
            function fireOmegaBlob(omegaFollower) {
                 if (Date.now() - omegaFollower.lastFireTime < omegaFireCooldown) {
                    return;
                }

                const distance = omegaFollower.mesh.position.distanceTo(player.position);
                if (distance > throwingRange * 2) {
                    return;
                }

                omegaFollower.lastFireTime = Date.now();

                const blobGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                const blobMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                const projectile = new THREE.Mesh(blobGeometry, blobMaterial);
                projectile.position.copy(omegaFollower.mesh.position);
                projectile.castShadow = true;
                scene.add(projectile);

                const horizontalSpeed = 1.1;
                const horizontalDistance = new THREE.Vector2(player.position.x, player.position.z).distanceTo(new THREE.Vector2(omegaFollower.mesh.position.x, omegaFollower.mesh.position.z));
                const timeToHit = horizontalDistance / horizontalSpeed;

                const predictedPlayerPosition = new THREE.Vector3(
                    player.position.x,
                    player.position.y,
                    player.position.z
                );

                const initialYVelocity = (predictedPlayerPosition.y - omegaFollower.mesh.position.y + 0.5 * gravity * timeToHit * timeToHit) / timeToHit + 0.2;

                const direction = new THREE.Vector3();
                direction.subVectors(predictedPlayerPosition, omegaFollower.mesh.position).normalize();

                projectile.velocity = new THREE.Vector3(
                    direction.x * horizontalSpeed,
                    initialYVelocity,
                    direction.z * horizontalSpeed
                );

                followerProjectiles.push({ mesh: projectile, damage: omegaFollowerProjectileDamage, explosionDamage: omegaFollowerExplosionDamage });
            }

            function updateFollowerProjectiles() {
                const projectilesToRemove = [];
                followerProjectiles.forEach((projectile, index) => {
                    projectile.mesh.position.add(projectile.mesh.velocity);
                    projectile.mesh.velocity.y -= gravity;

                    const distToPlayer = projectile.mesh.position.distanceTo(player.position);
                    if (distToPlayer < 1.5) {
                        playerHealth -= projectile.damage;
                        if (playerHealth <= 0) {
                            playerHealth = 0;
                            endGame('lose');
                        }
                        updateHealthBar(player.healthBar, playerHealth, playerMaxHealth);
                        triggerFireEffect(projectile.mesh.position.x, projectile.mesh.position.z, projectile.explosionDamage);
                        scene.remove(projectile.mesh);
                        projectilesToRemove.push(index);
                        return;
                    }
                    
                    if (projectile.mesh.position.y <= 0.5) {
                        triggerFireEffect(projectile.mesh.position.x, projectile.mesh.position.z, projectile.explosionDamage);
                        scene.remove(projectile.mesh);
                        projectilesToRemove.push(index);
                    }
                });

                for (let i = projectilesToRemove.length - 1; i >= 0; i--) {
                    followerProjectiles.splice(projectilesToRemove[i], 1);
                }
            }
            
            function triggerFireEffect(x, z, damage) {
                const fireGeometry = new THREE.SphereGeometry(fireRadius, 32, 32);
                const fireMaterial = new THREE.MeshBasicMaterial({ color: 0xff4500, transparent: true, opacity: 0.5 });
                const fire = new THREE.Mesh(fireGeometry, fireMaterial.clone());
                fire.position.set(x, 0.1, z);
                scene.add(fire);
                
                const playerPos2D = new THREE.Vector2(player.position.x, player.position.z);
                const explosionCenter2D = new THREE.Vector2(x, z);
                const distanceToExplosion = playerPos2D.distanceTo(explosionCenter2D);

                if (distanceToExplosion < fireRadius) {
                    playerHealth -= damage;
                    if (playerHealth <= 0) {
                        playerHealth = 0;
                        endGame('lose');
                    }
                    updateHealthBar(player.healthBar, playerHealth, playerMaxHealth);
                }

                const startScale = 0.1;
                const endScale = 1.0;
                const startTime = Date.now();
                
                const animateFire = () => {
                    const elapsedTime = Date.now() - startTime;
                    const progress = elapsedTime / fireDuration;
                    
                    if (progress < 1) {
                        const scale = startScale + (endScale - startScale) * progress;
                        fire.scale.set(scale, scale, scale);
                        fire.material.opacity = 0.5 - (0.5 * progress);
                        requestAnimationFrame(animateFire);
                    } else {
                        scene.remove(fire);
                    }
                };
                animateFire();
                destroyBushesInFireRadius(x, z);
            }

            function destroyBushesInFireRadius(x, z) {
                const fireCenter = new THREE.Vector2(x, z);
                const remainingBushes = [];
                for (const bush of blocks) {
                    const bushPos2D = new THREE.Vector2(bush.mesh.position.x, bush.mesh.position.z);
                    const dist = bushPos2D.distanceTo(fireCenter);
                    if (dist < fireRadius + bush.radius) {
                        scene.remove(bush.mesh);
                    } else {
                        remainingBushes.push(bush);
                    }
                }
                blocks = remainingBushes;
            }

            function firePlayerProjectile() {
                const projectileGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const projectileMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                const newProjectile = new THREE.Mesh(projectileGeometry, projectileMaterial);

                 const shootSound = document.getElementById('shoot-sound');
                shootSound.currentTime = 0; // rewind to start
                shootSound.play();

                
                const forwardVector = new THREE.Vector3();
                const spawnPosition = new THREE.Vector3();

                if (isFirstPersonView) {
                    camera.getWorldPosition(spawnPosition);
                    camera.getWorldDirection(forwardVector);
                } else {
                    player.getWorldPosition(spawnPosition);
                    forwardVector.set(
                        -Math.sin(player.rotation.y),
                        0,
                        -Math.cos(player.rotation.y)
                    ).normalize();
                }
                
                newProjectile.position.copy(spawnPosition);
                newProjectile.velocity = forwardVector.multiplyScalar(playerProjectileSpeed);
                newProjectile.castShadow = true;
                scene.add(newProjectile);
                playerProjectiles.push(newProjectile);
            }
            
            function updatePlayerProjectiles() {
                const projectilesToRemove = [];
                const followersToRemove = [];
                const superFollowersToRemove = [];
                const omegaFollowersToRemove = []; // NEW: Array for omega followers to remove
                const maxDistance = 100;

                playerProjectiles.forEach((proj, projIndex) => {
                    proj.position.add(proj.velocity);
                    
                    let hitSomething = false;

                    // Check for collision with normal followers
                    followers.forEach((follower, followerIndex) => {
                        const dist = proj.position.distanceTo(follower.mesh.position);
                        if (dist < 1.5) {
                            follower.health -= playerShotDamage;
                            updateHealthBar(follower.healthBar, follower.health, followerMaxHealth);
                            if (follower.health <= 0) {
                                followersToRemove.push(followerIndex);
                                createHealthOrb(follower.mesh.position);
                                addKill();
                            }
                            hitSomething = true;
                        }
                    });

                    // Check for collision with super followers
                    superFollowers.forEach((superFollower, superIndex) => {
                        const dist = proj.position.distanceTo(superFollower.mesh.position);
                        if (dist < 2.5) {
                            superFollower.health -= playerShotDamage;
                            updateHealthBar(superFollower.healthBar, superFollower.health, superFollowerMaxHealth);
                            if (superFollower.health <= 0) {
                                superFollowersToRemove.push(superIndex);
                                createHealthOrb(superFollower.mesh.position);
                                addKill();
                            }
                            hitSomething = true;
                        }
                    });
                    
                    // NEW: Check for collision with omega followers
                    omegaFollowers.forEach((omegaFollower, omegaIndex) => {
                        const dist = proj.position.distanceTo(omegaFollower.mesh.position);
                        if (dist < 3.5) {
                            omegaFollower.health -= playerShotDamage;
                            updateHealthBar(omegaFollower.healthBar, omegaFollower.health, omegaFollowerMaxHealth);
                            if (omegaFollower.health <= 0) {
                                omegaFollowersToRemove.push(omegaIndex);
                                createHealthOrb(omegaFollower.mesh.position);
                                addKill();
                            }
                            hitSomething = true;
                        }
                    });

                    if (hitSomething) {
                        scene.remove(proj);
                        projectilesToRemove.push(projIndex);
                    }
                    
                    if (proj.position.distanceTo(player.position) > maxDistance) {
                        scene.remove(proj);
                        projectilesToRemove.push(projIndex);
                    }
                });

                for (let i = projectilesToRemove.length - 1; i >= 0; i--) {
                    playerProjectiles.splice(projectilesToRemove[i], 1);
                }

                followersToRemove.sort((a, b) => b - a).forEach(index => {
                    scene.remove(followers[index].mesh);
                    followers.splice(index, 1);
                });

                superFollowersToRemove.sort((a, b) => b - a).forEach(index => {
                    scene.remove(superFollowers[index].mesh);
                    superFollowers.splice(index, 1);
                });
                
                omegaFollowersToRemove.sort((a, b) => b - a).forEach(index => {
                    scene.remove(omegaFollowers[index].mesh);
                    omegaFollowers.splice(index, 1);
                });

                if (followers.length === 0 && superFollowers.length === 0 && omegaFollowers.length === 0 && !isWaveTransitioning) {
                    endWave();
                }

                while (followers.length >= combinationThreshold) {
                    combineFollowers();
                }
            }

            function checkHealthOrbCollisions() {
                const orbsToRemove = [];
                healthOrbs.forEach((orb, index) => {
                    const dist = orb.position.distanceTo(player.position);
                    if (dist < 1.5) {
                        playerHealth = Math.min(playerMaxHealth, playerHealth + healthOrbHealAmount);
                        updateHealthBar(player.healthBar, playerHealth, playerMaxHealth);
                        scene.remove(orb);
                        orbsToRemove.push(index);
                    }
                });

                for (let i = orbsToRemove.length - 1; i >= 0; i--) {
                    healthOrbs.splice(orbsToRemove[i], 1);
                }
            }

            function showBuffMenu() {
                const shuffledBuffs = [...buffs].sort(() => 0.5 - Math.random());
                const buffChoice1 = shuffledBuffs[0];
                const buffChoice2 = shuffledBuffs[1];
                
                buffChoice1Button.querySelector('.buff-title').textContent = buffChoice1.name;
                buffChoice1Button.querySelector('.buff-description').textContent = buffChoice1.description;
                buffChoice1Button.buff = buffChoice1;
                
                buffChoice2Button.querySelector('.buff-title').textContent = buffChoice2.name;
                buffChoice2Button.querySelector('.buff-description').textContent = buffChoice2.description;
                buffChoice2Button.buff = buffChoice2;
                
                buffMenu.style.display = 'block';
                isPaused = true;
            }
            
            // Modified endWave function to despawn orbs
            function endWave() {
                isWaveTransitioning = true;
                waveCount++;
                waveMessage.textContent = `Wave ${waveCount}`;
                waveMessage.style.display = 'block';
                document.exitPointerLock();
                
                // NEW: Despawn all remaining health orbs
                healthOrbs.forEach(orb => scene.remove(orb));
                healthOrbs = [];

                setTimeout(() => {
                    waveMessage.style.display = 'none';
                    showBuffMenu();
                }, 2000);
            }

            function spawnNewWave(numFollowers) {
                for (let i = 0; i < numFollowers; i++) {
                    let spawnPosition = new THREE.Vector3();
                    let spawnAttempts = 0;
                    let isClose = true;
                    
                    while (isClose && spawnAttempts < 100) {
                        spawnPosition.x = (Math.random() - 0.5) * worldRadius * 2;
                        spawnPosition.z = (Math.random() - 0.5) * worldRadius * 2;
                        spawnPosition.y = 1;
                        
                        if (spawnPosition.distanceTo(player.position) > 10) {
                            isClose = false;
                        }
                        spawnAttempts++;
                    }

                    if (isClose) {
                        const angle = Math.random() * Math.PI * 2;
                        spawnPosition.x = player.position.x + 50 * Math.cos(angle);
                        spawnPosition.z = player.position.z + 50 * Math.sin(angle);
                        spawnPosition.y = 1;
                    }

                    const followerGeometry = new THREE.BoxGeometry(2, 2, 2);
                    const followerMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                    const newFollowerMesh = new THREE.Mesh(followerGeometry, followerMaterial);
                    
                    newFollowerMesh.position.copy(spawnPosition);
                    newFollowerMesh.castShadow = true;
                    scene.add(newFollowerMesh);
                    
                    const followerHealthBar = createHealthBar(2, 0.2);
                    followerHealthBar.position.y = 2;
                    newFollowerMesh.add(followerHealthBar);
                    
                    followers.push({
                        mesh: newFollowerMesh,
                        health: followerMaxHealth,
                        healthBar: followerHealthBar,
                        lastFireTime: 0
                    });
                }
            }

            function endGame(result) {
                gameIsOver = true;
                if (result === 'win') {
                    gameMessage.textContent = 'You Win!';
                } else {
                    gameMessage.textContent = 'Game Over';
                }
                gameMessage.style.display = 'block';

                  saveHighScore();
            }

            // --- Main Game Loop ---
            function animate() {
                if (gameIsOver || isPaused) {
                    requestAnimationFrame(animate);
                    return;
                }
                requestAnimationFrame(animate);
                
                // Player Physics and Movement
                let moveDirection = new THREE.Vector3();
                if (isFirstPersonView) {
                    camera.rotation.y = cameraRotation.y;
                    camera.rotation.x = cameraRotation.x;

                    const cameraForward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);

                    if (keys['w'] || keys['arrowup']) {
                        moveDirection.add(cameraForward);
                    }
                    if (keys['s'] || keys['arrowdown']) {
                        moveDirection.sub(cameraForward);
                    }
                    if (keys['a'] || keys['arrowleft']) {
                        moveDirection.sub(cameraRight);
                    }
                    if (keys['d'] || keys['arrowright']) {
                        moveDirection.add(cameraRight);
                    }
                    moveDirection.normalize().multiplyScalar(playerSpeed);
                    player.position.x += moveDirection.x;
                    player.position.z += moveDirection.z;
                } else {
                    if (keys['a'] || keys['arrowleft']) {
                        player.rotation.y += rotationSpeed;
                    }
                    if (keys['d'] || keys['arrowright']) {
                        player.rotation.y -= rotationSpeed;
                    }
                    let forward = 0;
                    if (keys['w'] || keys['arrowup']) {
                        forward = -playerSpeed;
                    } else if (keys['s'] || keys['arrowdown']) {
                        forward = playerSpeed;
                    }
                    const horizontalVelocity = new THREE.Vector3(
                        Math.sin(player.rotation.y) * forward,
                        0,
                        Math.cos(player.rotation.y) * forward
                    );
                    player.position.x += horizontalVelocity.x;
                    player.position.z += horizontalVelocity.z;
                }
                
                playerVelocity.y -= gravity;
                player.position.y += playerVelocity.y;
                
                onGround = false;
                const groundHeight = 1;
                if (player.position.y <= groundHeight) {
                    player.position.y = groundHeight;
                    playerVelocity.y = 0;
                    onGround = true;
                }
                
                if (player.position.y < voidYLevel) {
                    endGame('lose');
                    return;
                }
                
                let isInsideAnyBush = false;
                for(const bush of blocks) {
                    for (const sphere of bush.mesh.children) {
                        const sphereWorldPosition = new THREE.Vector3();
                        sphere.getWorldPosition(sphereWorldPosition);
                        const playerPos2D = new THREE.Vector2(player.position.x, player.position.z);
                        const spherePos2D = new THREE.Vector2(sphereWorldPosition.x, sphereWorldPosition.z);
                        const dist = playerPos2D.distanceTo(spherePos2D);
                        const sphereRadius = sphere.geometry.parameters.radius;
                        if (dist < sphereRadius + 0.3) {
                            isInsideAnyBush = true;
                            break;
                        }
                    }
                    if (isInsideAnyBush) break;
                }
                
                if (!isInsideAnyBush) {
                    followers.forEach(follower => {
                        const targetPosition = new THREE.Vector3(player.position.x, follower.mesh.position.y, player.position.z);
                        follower.mesh.lookAt(targetPosition);
                        const direction = new THREE.Vector3();
                        direction.subVectors(targetPosition, follower.mesh.position).normalize();
                        follower.mesh.position.addScaledVector(direction, followerSpeed);

                        // Every follower fires independently
                        fireBlob(follower);
                    });

                    superFollowers.forEach(superFollower => {
                        const targetPosition = new THREE.Vector3(player.position.x, superFollower.mesh.position.y, player.position.z);
                        superFollower.mesh.lookAt(targetPosition);
                        const direction = new THREE.Vector3();
                        direction.subVectors(targetPosition, superFollower.mesh.position).normalize();
                        superFollower.mesh.position.addScaledVector(direction, superFollowerSpeed);

                        // Every super follower fires independently
                        fireSuperBlob(superFollower);
                    });
                    
                    // NEW: Logic for the new enemy type
                    omegaFollowers.forEach(omegaFollower => {
                        const targetPosition = new THREE.Vector3(player.position.x, omegaFollower.mesh.position.y, player.position.z);
                        omegaFollower.mesh.lookAt(targetPosition);
                        const direction = new THREE.Vector3();
                        direction.subVectors(targetPosition, omegaFollower.mesh.position).normalize();
                        omegaFollower.mesh.position.addScaledVector(direction, omegaFollowerSpeed);
                        
                        fireOmegaBlob(omegaFollower);
                    });
                }
                
                // NEW: Check for super follower combination
                if (superFollowers.length >= omegaFollowerThreshold) {
                    combineSuperFollowers();
                }

                updateFollowerProjectiles();
                updatePlayerProjectiles();
                checkHealthOrbCollisions();

                player.healthBar.lookAt(camera.position);
                followers.forEach(f => f.healthBar.lookAt(camera.position));
                superFollowers.forEach(f => f.healthBar.lookAt(camera.position));
                omegaFollowers.forEach(f => f.healthBar.lookAt(camera.position)); // NEW: Update the new enemy's health bar

                if (isFirstPersonView) {
                    camera.position.copy(player.position);
                    camera.position.y += 0.5;
                    player.rotation.y = cameraRotation.y;
                } else {
                    const cameraDistance = 20;
                    camera.position.set(
                        player.position.x + Math.sin(player.rotation.y) * cameraDistance,
                        player.position.y + 10,
                        player.position.z + Math.cos(player.rotation.y) * cameraDistance
                    );
                    camera.lookAt(player.position);
                }
                
                renderer.render(scene, camera);
            }
            
            init();
            animate();
        };
    </script>
</body>
</html>

